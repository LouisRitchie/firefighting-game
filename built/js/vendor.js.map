{"version":3,"sources":["node_modules/handlebars-brunch/vendor/handlebars.runtime-1.0.rc.1.js","vendor/rogue.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"built/js/vendor.js","sourcesContent":["// lib/handlebars/base.js\n\n/*jshint eqnull:true*/\nthis.Handlebars = {};\n\n(function(Handlebars) {\n\nHandlebars.VERSION = \"1.0.rc.1\";\n\nHandlebars.helpers  = {};\nHandlebars.partials = {};\n\nHandlebars.registerHelper = function(name, fn, inverse) {\n  if(inverse) { fn.not = inverse; }\n  this.helpers[name] = fn;\n};\n\nHandlebars.registerPartial = function(name, str) {\n  this.partials[name] = str;\n};\n\nHandlebars.registerHelper('helperMissing', function(arg) {\n  if(arguments.length === 2) {\n    return undefined;\n  } else {\n    throw new Error(\"Could not find property '\" + arg + \"'\");\n  }\n});\n\nvar toString = Object.prototype.toString, functionType = \"[object Function]\";\n\nHandlebars.registerHelper('blockHelperMissing', function(context, options) {\n  var inverse = options.inverse || function() {}, fn = options.fn;\n\n\n  var ret = \"\";\n  var type = toString.call(context);\n\n  if(type === functionType) { context = context.call(this); }\n\n  if(context === true) {\n    return fn(this);\n  } else if(context === false || context == null) {\n    return inverse(this);\n  } else if(type === \"[object Array]\") {\n    if(context.length > 0) {\n      return Handlebars.helpers.each(context, options);\n    } else {\n      return inverse(this);\n    }\n  } else {\n    return fn(context);\n  }\n});\n\nHandlebars.K = function() {};\n\nHandlebars.createFrame = Object.create || function(object) {\n  Handlebars.K.prototype = object;\n  var obj = new Handlebars.K();\n  Handlebars.K.prototype = null;\n  return obj;\n};\n\nHandlebars.registerHelper('each', function(context, options) {\n  var fn = options.fn, inverse = options.inverse;\n  var ret = \"\", data;\n\n  if (options.data) {\n    data = Handlebars.createFrame(options.data);\n  }\n\n  if(context && context.length > 0) {\n    for(var i=0, j=context.length; i<j; i++) {\n      if (data) { data.index = i; }\n      ret = ret + fn(context[i], { data: data });\n    }\n  } else {\n    ret = inverse(this);\n  }\n  return ret;\n});\n\nHandlebars.registerHelper('if', function(context, options) {\n  var type = toString.call(context);\n  if(type === functionType) { context = context.call(this); }\n\n  if(!context || Handlebars.Utils.isEmpty(context)) {\n    return options.inverse(this);\n  } else {\n    return options.fn(this);\n  }\n});\n\nHandlebars.registerHelper('unless', function(context, options) {\n  var fn = options.fn, inverse = options.inverse;\n  options.fn = inverse;\n  options.inverse = fn;\n\n  return Handlebars.helpers['if'].call(this, context, options);\n});\n\nHandlebars.registerHelper('with', function(context, options) {\n  return options.fn(context);\n});\n\nHandlebars.registerHelper('log', function(context) {\n  Handlebars.log(context);\n});\n\n}(this.Handlebars));\n;\n// lib/handlebars/utils.js\nHandlebars.Exception = function(message) {\n  var tmp = Error.prototype.constructor.apply(this, arguments);\n\n  for (var p in tmp) {\n    if (tmp.hasOwnProperty(p)) { this[p] = tmp[p]; }\n  }\n\n  this.message = tmp.message;\n};\nHandlebars.Exception.prototype = new Error();\n\n// Build out our basic SafeString type\nHandlebars.SafeString = function(string) {\n  this.string = string;\n};\nHandlebars.SafeString.prototype.toString = function() {\n  return this.string.toString();\n};\n\n(function() {\n  var escape = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\",\n    \"`\": \"&#x60;\"\n  };\n\n  var badChars = /[&<>\"'`]/g;\n  var possible = /[&<>\"'`]/;\n\n  var escapeChar = function(chr) {\n    return escape[chr] || \"&amp;\";\n  };\n\n  Handlebars.Utils = {\n    escapeExpression: function(string) {\n      // don't escape SafeStrings, since they're already safe\n      if (string instanceof Handlebars.SafeString) {\n        return string.toString();\n      } else if (string == null || string === false) {\n        return \"\";\n      }\n\n      if(!possible.test(string)) { return string; }\n      return string.replace(badChars, escapeChar);\n    },\n\n    isEmpty: function(value) {\n      if (typeof value === \"undefined\") {\n        return true;\n      } else if (value === null) {\n        return true;\n      } else if (value === false) {\n        return true;\n      } else if(Object.prototype.toString.call(value) === \"[object Array]\" && value.length === 0) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  };\n})();;\n// lib/handlebars/runtime.js\nHandlebars.VM = {\n  template: function(templateSpec) {\n    // Just add water\n    var container = {\n      escapeExpression: Handlebars.Utils.escapeExpression,\n      invokePartial: Handlebars.VM.invokePartial,\n      programs: [],\n      program: function(i, fn, data) {\n        var programWrapper = this.programs[i];\n        if(data) {\n          return Handlebars.VM.program(fn, data);\n        } else if(programWrapper) {\n          return programWrapper;\n        } else {\n          programWrapper = this.programs[i] = Handlebars.VM.program(fn);\n          return programWrapper;\n        }\n      },\n      programWithDepth: Handlebars.VM.programWithDepth,\n      noop: Handlebars.VM.noop\n    };\n\n    return function(context, options) {\n      options = options || {};\n      return templateSpec.call(container, Handlebars, context, options.helpers, options.partials, options.data);\n    };\n  },\n\n  programWithDepth: function(fn, data, $depth) {\n    var args = Array.prototype.slice.call(arguments, 2);\n\n    return function(context, options) {\n      options = options || {};\n\n      return fn.apply(this, [context, options.data || data].concat(args));\n    };\n  },\n  program: function(fn, data) {\n    return function(context, options) {\n      options = options || {};\n\n      return fn(context, options.data || data);\n    };\n  },\n  noop: function() { return \"\"; },\n  invokePartial: function(partial, name, context, helpers, partials, data) {\n    var options = { helpers: helpers, partials: partials, data: data };\n\n    if(partial === undefined) {\n      throw new Handlebars.Exception(\"The partial \" + name + \" could not be found\");\n    } else if(partial instanceof Function) {\n      return partial(context, options);\n    } else if (!Handlebars.compile) {\n      throw new Handlebars.Exception(\"The partial \" + name + \" could not be compiled when running in runtime-only mode\");\n    } else {\n      partials[name] = Handlebars.compile(partial, {data: data !== undefined});\n      return partials[name](context, options);\n    }\n  }\n};\n\nHandlebars.template = Handlebars.VM.template;\n;\n","// Generated by CoffeeScript 1.3.3\n(function() {\n  var Animation, AssetManager, Entity, Eventer, Factory, Game, GameLoop, Importer, Keyboard, Mouse, Rogue, RollingAverage, SpriteSheet, TileMap, Tween, ViewPort, b, c, collision, find, gfx, intergrate, log, math, physics, sqrt, util, v,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    __slice = [].slice;\n\n  gfx = {};\n\n  gfx.scale = function(simg, s, pixel) {\n    var ctx, dimg;\n    if (pixel) {\n      dimg = util.canvas();\n      dimg.width = simg.width * s[0];\n      dimg.height = simg.height * s[1];\n      ctx = dimg.getContext(\"2d\");\n      ctx.scale(s[0], s[1]);\n      ctx.imageSmoothingEnabled = ctx.mozImageSmoothingEnabled = ctx.webkitImageSmoothingEnabled = false;\n      ctx.drawImage(simg, 0, 0, simg.width, simg.height);\n      ctx.fillStyle = ctx.createPattern(simg, 'repeat');\n      ctx.fillRect(0, 0, simg.width, simg.height);\n      return dimg;\n    } else {\n      simg.width *= s[0];\n      simg.height *= s[1];\n      ctx = simg.getContext(\"2d\");\n      ctx.scale(s[0], s[1]);\n      return simg;\n    }\n  };\n\n  gfx.edit = function(data, x, y, r, g, b, a) {\n    var darray, index;\n    darray = data.data;\n    index = (y * data.width + x) * 4;\n    if (r || g || b || a) {\n      darray[index] = r || darray[index];\n      darray[index++] = g || darray[index];\n      darray[index++] = b || darray[index];\n      darray[index++] = a || darray[index];\n      return data.data = darray;\n    } else {\n      return [darray[index], darray[index++], darray[index++], darray[index++]];\n    }\n  };\n\n  gfx.edgeDetect = function(img) {\n    var ctx, data, lookup, points, x, y, _i, _j, _ref, _ref1;\n    ctx = img.getContext(\"2d\");\n    data = ctx.getImageData(0, 0, img.width, img.height);\n    lookup = function(x, y) {\n      return gfx.edit(data, x, y)[3];\n    };\n    points = [];\n    for (x = _i = 0, _ref = img.width; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {\n      for (y = _j = 0, _ref1 = img.height; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {\n        if (lookup(x, y) > 0) {\n          if (lookup(x + 1, y) === 0) {\n            points.push([x, y, \"right\"]);\n          } else if (lookup(x - 1, y) === 0) {\n            points.push([x, y, \"left\"]);\n          } else if (lookup(x, y + 1) === 0) {\n            points.push([x, y, \"down\"]);\n          } else if (lookup(x, y - 1) === 0) {\n            points.push([x, y, \"up\"]);\n          }\n        }\n      }\n    }\n    return points;\n  };\n\n  AssetManager = (function() {\n    var callback, codecs, filetypes;\n\n    function AssetManager(manifest) {\n      var contents, name, _ref;\n      this.callbacks = {\n        load: {},\n        complete: {},\n        error: {}\n      };\n      this.base = manifest.baseUrl || \"\";\n      this.packs = {};\n      this.total = this.complete = 0;\n      _ref = manifest.packs;\n      for (name in _ref) {\n        contents = _ref[name];\n        this.packs[name] = contents;\n        this.total += contents.length;\n      }\n      manifest.preload && this.downloadAll();\n    }\n\n    AssetManager.prototype.download = function(pack) {\n      var asset, contents, data, ext, key, that, value, _i, _len;\n      that = this;\n      contents = this.packs[pack];\n      if (contents == null) {\n        log(2, \"Pack \" + pack + \" does not exist\");\n        return false;\n      }\n      if (contents.loaded !== contents.length) {\n        contents.loaded = 0;\n        for (_i = 0, _len = contents.length; _i < _len; _i++) {\n          asset = contents[_i];\n          ext = asset.src.split(\".\").pop();\n          asset.src = this.base + asset.src;\n          asset.pack = pack;\n          for (key in filetypes) {\n            value = filetypes[key];\n            if (__indexOf.call(value, ext) >= 0) {\n              asset.type = key;\n            }\n          }\n          if (asset.type == null) {\n            log(2, \"Unknown asset type for extension: \" + ext);\n            return false;\n          }\n          switch (asset.type) {\n            case \"image\":\n              data = new Image();\n              data.a = asset;\n              data.onload = function() {\n                var a, canvas;\n                canvas = util.imgToCanvas(this);\n                a = util.mixin(canvas, this.a);\n                return that.loaded(a);\n              };\n              data.onerror = function() {\n                return callback.call(that, this.a, false);\n              };\n              data.src = asset.src;\n              break;\n            case \"sound\":\n              asset.alt = this.base + asset.alt;\n              data = new Audio();\n              data.preload = \"none\";\n              asset = util.mixin(data, asset);\n              if (!data.canPlayType(codecs[ext])) {\n                asset.src = asset.alt;\n              }\n              asset.onerror = function() {\n                return callback.call(that, asset, false);\n              };\n              asset.addEventListener('canplaythrough', function() {\n                return that.loaded(this);\n              });\n              asset.load();\n          }\n        }\n      }\n    };\n\n    AssetManager.prototype.loaded = function(asset) {\n      var pack, _name, _ref;\n      pack = this.packs[asset.pack];\n      if ((_ref = this[_name = asset.pack]) == null) {\n        this[_name] = {};\n      }\n      this[asset.pack][asset.name] = asset;\n      return callback.call(this, asset, true);\n    };\n\n    AssetManager.prototype.downloadAll = function() {\n      var key, val, _ref, _results;\n      _ref = this.packs;\n      _results = [];\n      for (key in _ref) {\n        val = _ref[key];\n        _results.push(this.download(key));\n      }\n      return _results;\n    };\n\n    AssetManager.prototype.on = function(e, pack, fn) {\n      var _base, _name, _ref, _ref1;\n      if (e === \"load\" || e === \"complete\" || e === \"error\") {\n        if (pack === \"all\") {\n          if ((_ref = this[_name = \"on\" + e]) == null) {\n            this[_name] = [];\n          }\n          return this[\"on\" + e].push(fn);\n        } else {\n          if ((_ref1 = (_base = this.callbacks[e])[pack]) == null) {\n            _base[pack] = [];\n          }\n          return this.callbacks[e][pack].push(fn);\n        }\n      }\n    };\n\n    callback = function(asset, status) {\n      var afuncs, apercent, func, funcs, pack, percent, s, _i, _j, _len, _len1, _results;\n      pack = this.packs[asset.pack];\n      percent = math.round(++pack.loaded / pack.length * 100);\n      apercent = math.round(++this.complete / this.total * 100);\n      funcs = [];\n      afuncs = [];\n      if (status) {\n        s = \"load\";\n      } else {\n        \"error\";\n\n      }\n      funcs = funcs.concat(this.callbacks[s][asset.pack]);\n      afuncs = afuncs.concat(this[\"on\" + s]);\n      if (percent === 100) {\n        funcs = funcs.concat(this.callbacks.complete[asset.pack]);\n      }\n      if (apercent === 100) {\n        afuncs = afuncs.concat(this.oncomplete);\n      }\n      for (_i = 0, _len = funcs.length; _i < _len; _i++) {\n        func = funcs[_i];\n        if (func) {\n          func(asset, percent);\n        }\n      }\n      _results = [];\n      for (_j = 0, _len1 = afuncs.length; _j < _len1; _j++) {\n        func = afuncs[_j];\n        if (func) {\n          _results.push(func(asset, apercent));\n        }\n      }\n      return _results;\n    };\n\n    filetypes = {\n      image: [\"png\", \"gif\", \"jpg\", \"jpeg\", \"tiff\"],\n      sound: [\"mp3\", \"ogg\"]\n    };\n\n    codecs = {\n      'mp3': 'audio/mpeg',\n      'ogg': 'audio/ogg'\n    };\n\n    return AssetManager;\n\n  })();\n\n  SpriteSheet = (function() {\n\n    function SpriteSheet(options) {\n      var c, cx, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;\n      this.options = options;\n      this.img = this.options.image;\n      this.res = this.options.res || [32, 32];\n      this.length = 0;\n      for (x = _i = 0, _ref = this.img.width, _ref1 = this.res[0]; 0 <= _ref ? _i < _ref : _i > _ref; x = _i += _ref1) {\n        for (y = _j = 0, _ref2 = this.img.height, _ref3 = this.res[1]; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; y = _j += _ref3) {\n          c = util.canvas();\n          cx = c.getContext(\"2d\");\n          c.width = this.res[0];\n          c.height = this.res[1];\n          cx.drawImage(this.img, x, y, c.width, c.height, 0, 0, c.width, c.height);\n          this[this.length] = c;\n          this.length++;\n        }\n      }\n    }\n\n    SpriteSheet.prototype.slice = function(start, end) {\n      return Array.prototype.slice.call(this, start, end);\n    };\n\n    return SpriteSheet;\n\n  })();\n\n  Animation = (function() {\n\n    function Animation(options) {\n      this.options = options;\n      this.sprites = this.options.spritesheet;\n      this.speed = this.options.speed || 6;\n      this.i = this.options.start || 0;\n      this.t = 0;\n      this.loop = this.options.loop || true;\n      this.bounce = this.options.bounce || false;\n      this.finished = false;\n      this.onFinish = this.options.onFinish;\n      this.dir = 1;\n      this.frame = this.sprites[this.i];\n    }\n\n    Animation.prototype.next = function() {\n      if (this.t === this.speed && !this.finished) {\n        this.frame = this.sprites[this.i += this.dir];\n        this.t = 0;\n      }\n      if (this.i === this.sprites.length - 1) {\n        if (!this.loop) {\n          this.finished = true;\n          if (this.onFinish) {\n            this.onFinish();\n          }\n        } else {\n          if (this.bounce) {\n            this.dir = -1;\n          } else {\n            this.i = 0;\n          }\n        }\n      }\n      if (this.i === 0 && this.dir === -1) {\n        this.dir = 1;\n      }\n      this.t++;\n      return this.frame;\n    };\n\n    return Animation;\n\n  })();\n\n  Entity = (function() {\n\n    function Entity(options) {\n      this.updates = [];\n      util.mixin(this, options);\n      this.ev = new Eventer(this);\n      this.components = new Importer(Rogue.components, this);\n      if (this.require) {\n        this.components.add(this.require);\n      }\n      delete this.require;\n      if (this.parent) {\n        this.parent.e.push(this);\n      }\n    }\n\n    Entity.prototype.update = function(dt) {\n      var func, _i, _len, _ref, _results;\n      _ref = this.updates;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        func = _ref[_i];\n        if (func != null) {\n          _results.push(func.call(this, dt));\n        }\n      }\n      return _results;\n    };\n\n    return Entity;\n\n  })();\n\n  Importer = (function() {\n\n    function Importer(from, dest, mixin) {\n      this.from = from;\n      this.dest = dest;\n      this.mixin = mixin != null ? mixin : true;\n    }\n\n    Importer.prototype.add = function(imports) {\n      var imp, key, val, _i, _len, _ref, _results;\n      imports = [].concat(imports);\n      _results = [];\n      for (_i = 0, _len = imports.length; _i < _len; _i++) {\n        imp = imports[_i];\n        if (!(this[imp] != null)) {\n          if (this.from[imp] != null) {\n            this[imp] = new this.from[imp];\n            if (this.mixin) {\n              _ref = this[imp];\n              for (key in _ref) {\n                val = _ref[key];\n                if (key !== \"onadd\" && key !== \"onremove\" && key !== \"run\" && (val != null)) {\n                  this.dest[key] = val;\n                }\n              }\n            }\n            if (this[imp].onadd) {\n              _results.push(this[imp].onadd.call(this.dest));\n            } else {\n              _results.push(void 0);\n            }\n          } else {\n            _results.push(log(2, \"mixin \" + imp + \" does not exist!\"));\n          }\n        }\n      }\n      return _results;\n    };\n\n    Importer.prototype.remove = function(imports) {\n      var imp, key, val, _i, _len, _ref, _results;\n      imports = [].concat(imports);\n      _results = [];\n      for (_i = 0, _len = imports.length; _i < _len; _i++) {\n        imp = imports[_i];\n        if (!(this[imp] != null)) {\n          continue;\n        }\n        if (this.mixin) {\n          _ref = this[imp];\n          for (key in _ref) {\n            val = _ref[key];\n            if ((this.dest[key] != null) && this.dest[key] === this[imp][key]) {\n              delete this.dest[key];\n            }\n          }\n        }\n        if (this[imp].onremove) {\n          this[imp].onremove.call(this.dest);\n        }\n        _results.push(delete this[imp]);\n      }\n      return _results;\n    };\n\n    return Importer;\n\n  })();\n\n  Factory = (function() {\n\n    function Factory(options) {\n      var i, _i, _ref;\n      this.hanger = [];\n      this.entity = options.entity || Rogue.Entity;\n      this.opts = options.options || {};\n      this.initial = options.initial;\n      for (i = _i = 0, _ref = this.initial; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        this.hanger.push(this.build());\n      }\n    }\n\n    Factory.prototype.deploy = function() {\n      var e;\n      if (this.hanger.length > 0) {\n        e = this.hanger.pop();\n      } else {\n        e = this.build();\n      }\n      if (e.parent) {\n        e.parent.add(e);\n      }\n      return e;\n    };\n\n    Factory.prototype.build = function() {\n      var ent;\n      ent = new this.entity(this.opts);\n      ent.factory = this;\n      ent[\"return\"] = function() {\n        if (this.parent) {\n          this.parent.remove(this);\n        }\n        this.factory.hanger.push(this);\n        return util.mixin(this, this.factory.opts);\n      };\n      return ent;\n    };\n\n    return Factory;\n\n  })();\n\n  c = {};\n\n  c.sprite = (function() {\n\n    function sprite() {}\n\n    sprite.prototype.onadd = function() {\n      var _ref, _ref1, _ref2, _ref3;\n      if (!this.image) {\n        log(2, \"Sprite entities require an image\");\n      }\n      if ((_ref = this.x) == null) {\n        this.x = 0;\n      }\n      if ((_ref1 = this.y) == null) {\n        this.y = 0;\n      }\n      if ((_ref2 = this.angle) == null) {\n        this.angle = 0;\n      }\n      if ((_ref3 = this.opacity) == null) {\n        this.opacity = 255;\n      }\n      if (this.scaleFactor != null) {\n        return this.scale(this.scaleFactor, this.pixel);\n      } else {\n        return this.recalculateImage();\n      }\n    };\n\n    sprite.prototype.draw = function() {\n      var r;\n      c = this.parent.context;\n      r = math.round;\n      c.save();\n      c.translate(r(this.x - this.xOffset), r(this.y - this.yOffset));\n      c.rotate(this.angle * Math.PI / 180);\n      c.globalAlpha = this.opacity;\n      c.drawImage(this.image, 0, 0, this.width, this.height);\n      return c.restore();\n    };\n\n    sprite.prototype.scale = function(scaleFactor, pixel) {\n      this.scaleFactor = scaleFactor;\n      this.pixel = pixel;\n      this.image = gfx.scale(this.image, this.scaleFactor, this.pixel);\n      return this.recalculateImage();\n    };\n\n    sprite.prototype.rect = function() {\n      return {\n        x: this.x - this.xOffset,\n        y: this.y - this.yOffset,\n        width: this.width,\n        height: this.height\n      };\n    };\n\n    sprite.prototype.recalculateImage = function() {\n      this.width = this.image.width;\n      this.height = this.image.height;\n      this.xOffset = math.round(this.width / 2);\n      return this.yOffset = math.round(this.height / 2);\n    };\n\n    return sprite;\n\n  })();\n\n  c.move = (function() {\n\n    function move() {}\n\n    move.prototype.onadd = function() {\n      return this.components.add(\"sprite\");\n    };\n\n    move.prototype.move = function(x, y) {\n      this.x += x;\n      return this.y += y;\n    };\n\n    move.prototype.moveTo = function(x, y) {\n      this.x = x;\n      this.y = y;\n    };\n\n    return move;\n\n  })();\n\n  c.tile = (function() {\n\n    function tile() {}\n\n    tile.prototype.onadd = function() {\n      return this.components.add(\"sprite\");\n    };\n\n    tile.prototype.move = function(x, y) {\n      util.remove(this.tile.contents, this);\n      this.x += x;\n      this.y += y;\n      return this.tile.parent.place(this);\n    };\n\n    tile.prototype.moveTo = function(x, y) {\n      this.x = x;\n      this.y = y;\n      util.remove(this.tile.contents, this);\n      return this.tile.parent.place(this);\n    };\n\n    return tile;\n\n  })();\n\n  c.collide = (function() {\n\n    function collide() {}\n\n    collide.prototype.onadd = function() {\n      if (this.components[\"layer\"] == null) {\n        this.components.add(\"sprite\");\n      }\n      return this.solid = this.components[\"physics\"] != null ? false : true;\n    };\n\n    collide.prototype.findCollisions = function() {\n      var col, nearby, obj, _i, _len;\n      if (this.parent.hashmap) {\n        nearby = this.parent.hashmap.find(this);\n      } else {\n        nearby = this.parent.find([\"collide\"]);\n      }\n      this.colliding = [];\n      for (_i = 0, _len = nearby.length; _i < _len; _i++) {\n        obj = nearby[_i];\n        col = this.collide(obj);\n        if (col) {\n          this.ev.emit(\"hit\", col);\n          obj.ev.emit(\"hit\", col);\n          this.colliding.push(col);\n        }\n      }\n      return this.colliding;\n    };\n\n    collide.prototype.move = function(x, y) {\n      this.x += x;\n      this.y += y;\n      if (this.findCollisions().length > 0) {\n        this.x -= x;\n        this.y -= y;\n        if (Math.abs(x) < 1 && Math.abs(y) < 1) {\n          return false;\n        }\n        if (this.move(~~(x / 2), ~~(y / 2))) {\n          if (!this.move(~~(x / 2), ~~(y / 2))) {\n            return false;\n          } else {\n            return true;\n          }\n        } else {\n          return false;\n        }\n      } else {\n        return true;\n      }\n    };\n\n    return collide;\n\n  })();\n\n  c.layer = (function(_super) {\n\n    __extends(layer, _super);\n\n    function layer() {\n      return layer.__super__.constructor.apply(this, arguments);\n    }\n\n    layer.prototype.onadd = function() {\n      var _ref, _ref1, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;\n      if ((_ref = this.width) == null) {\n        this.width = this.image.width;\n      }\n      if ((_ref1 = this.height) == null) {\n        this.height = this.image.height;\n      }\n      if ((_ref2 = this.x) == null) {\n        this.x = 0;\n      }\n      if ((_ref3 = this.y) == null) {\n        this.y = 0;\n      }\n      if ((_ref4 = this.opacity) == null) {\n        this.opacity = 255;\n      }\n      if ((_ref5 = this.angle) == null) {\n        this.angle = 0;\n      }\n      this.xOffset = this.yOffset = 0;\n      if (this.scaleFactor) {\n        this.scale(this.scaleFactor);\n      }\n      if ((_ref6 = this.repeatX) == null) {\n        this.repeatX = false;\n      }\n      if ((_ref7 = this.repeatY) == null) {\n        this.repeatY = false;\n      }\n      if ((_ref8 = this.scrollY) == null) {\n        this.scrollY = false;\n      }\n      if ((_ref9 = this.scrollX) == null) {\n        this.scrollX = true;\n      }\n      return (_ref10 = this.speed) != null ? _ref10 : this.speed = 0;\n    };\n\n    layer.prototype.draw = function(x, y) {\n      var r, rect;\n      if (x == null) {\n        x = 0;\n      }\n      if (y == null) {\n        y = 0;\n      }\n      rect = this.parent.rect();\n      r = math.round;\n      if (!(x > 0 || y > 0)) {\n        if (this.scrollX) {\n          this.x = math.round(rect.x * this.speed);\n        }\n        if (this.scrollY) {\n          this.y = math.round(rect.y * this.speed);\n        }\n      }\n      c = this.parent.context;\n      c.save();\n      c.rotate(this.angle * Math.PI / 180);\n      c.globalAlpha = this.opacity;\n      c.translate(r(this.x + x), r(this.y + y));\n      c.drawImage(this.image, 0, 0, this.width, this.height);\n      c.restore();\n      if (this.repeatX && this.x + this.width + x < rect.x + rect.width) {\n        this.draw(x + this.width, 0);\n      }\n      if (this.repeatY && this.y + this.height + y < rect.y + rect.height) {\n        return this.draw(0, y + this.height);\n      }\n    };\n\n    return layer;\n\n  })(c.sprite);\n\n  c.tween = (function() {\n    var applytweens;\n\n    function tween() {}\n\n    tween.prototype.onadd = function() {\n      this.tweening = false;\n      this.tweens = [];\n      return this.updates.push(applytweens);\n    };\n\n    tween.prototype.onremove = function() {\n      return util.remove(this.updates, applytweens);\n    };\n\n    tween.prototype.tween = function(props, time, cb) {\n      this.tweens.push(new Tween(this, props, time, cb));\n      return this;\n    };\n\n    applytweens = function() {\n      var tween, _i, _len, _ref, _results;\n      _ref = this.tweens;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        tween = _ref[_i];\n        if (!tween.run()) {\n          _results.push(util.remove(this.tweens, tween));\n        } else {\n          _results.push(void 0);\n        }\n      }\n      return _results;\n    };\n\n    return tween;\n\n  })();\n\n  Tween = (function() {\n\n    function Tween(en, props, time, func, cb) {\n      var prop, val, _ref;\n      this.en = en;\n      this.props = props;\n      this.cb = cb;\n      this.func = func || function(t, b, c, d) {\n        return b + c * (t / d);\n      };\n      this.d = time * 60;\n      this.t = 0;\n      this.b = {};\n      this.c = {};\n      _ref = this.props;\n      for (prop in _ref) {\n        val = _ref[prop];\n        if (!(isNaN(val) || isNaN(this.en[prop]))) {\n          this.c[prop] = val - this.en[prop];\n          this.b[prop] = this.en[prop];\n        } else {\n          log(2, \"Cannot tween \" + prop + \" as only numerics can be tweened\");\n        }\n      }\n    }\n\n    Tween.prototype.run = function() {\n      var prop, val, _ref;\n      _ref = this.c;\n      for (prop in _ref) {\n        val = _ref[prop];\n        this.en[prop] = this.func(this.t, this.b[prop], this.c[prop], this.d);\n      }\n      if (this.t++ === this.d) {\n        if (this.cb != null) {\n          this.cb();\n        }\n        return false;\n      } else {\n        return true;\n      }\n    };\n\n    return Tween;\n\n  })();\n\n  physics = {};\n\n  b = {};\n\n  physics.behavior = b;\n\n  physics.intergrate = intergrate = function(e, dt) {\n    var d;\n    if (e.still()) {\n      return;\n    }\n    d = [];\n    v.scale(e.acc, 10000 / e.mass, e.acc);\n    v.add(v.scale(e.vel, dt, []), v.scale(e.acc, 0.5 * dt * dt, []), d);\n    v.add(e.vel, v.scale(e.acc, dt, []), e.vel);\n    e.move(d[0], d[1]);\n    v.scale(e.vel, 1 - (e.friction / 5), e.vel);\n    return e.acc = [0, 0];\n  };\n\n  sqrt = Math.sqrt;\n\n  v = {\n    add: function(a, b, c) {\n      c[0] = a[0] + b[0];\n      c[1] = a[1] + b[1];\n      return c;\n    },\n    sub: function(a, b, c) {\n      c[0] = a[0] - b[0];\n      c[1] = a[1] - b[1];\n      return c;\n    },\n    dir: function(a, b, c) {\n      var dx, dy, l;\n      dx = b[0] - a[0];\n      dy = b[1] - a[1];\n      l = 1 / (sqrt(dx * dx + dy * dy));\n      c[0] = dx * l;\n      c[1] = dy * l;\n      return c;\n    },\n    scale: function(a, b, c) {\n      c[0] = a[0] * b;\n      c[1] = a[1] * b;\n      return c;\n    },\n    proj: function(a, b, c) {\n      var dpb;\n      dpb = (a[0] * b[0] + a[1] * b[1]) / (b[0] * b[0] + b[1] * b[1]);\n      c[0] = dpb * b[0];\n      c[1] = dpb * b[1];\n      return c;\n    },\n    dot: function(a, b) {\n      return a[0] * b[0] + a[1] * b[1];\n    },\n    cross: function(a, b) {\n      return (a[0] * b[0]) - (a[1] * b[1]);\n    },\n    dist: function(a, b) {\n      var dx, dy;\n      dx = b[0] - a[0];\n      dy = b[1] - a[1];\n      return sqrt(dx * dx + dy * dy);\n    },\n    distSq: function(a, b) {\n      var dx, dy;\n      dx = b[0] - a[0];\n      dy = b[1] - a[1];\n      return dx * dx + dy * dy;\n    },\n    norm: function(a, c) {\n      var m;\n      m = sqrt(a[0] * a[0] + a[1] * a[1]);\n      c[0] = a[0] / m;\n      c[1] = a[1] / m;\n      return c;\n    },\n    clone: function(a, c) {\n      return c = a.slice(0);\n    },\n    neg: function(a, c) {\n      c[0] = -a[0];\n      return c[1] = -a[1](c);\n    },\n    mag: function(a) {\n      return sqrt(a[0] * a[0] + a[1] * a[1]);\n    },\n    magSq: function(a) {\n      return a[0] * a[0] + a[1] * a[1];\n    }\n  };\n\n  c.physics = (function() {\n\n    function physics() {}\n\n    physics.prototype.onadd = function() {\n      var _ref, _ref1, _ref2, _ref3;\n      this.components.add([\"move\", \"collide\"]);\n      this.behavior = new Importer(Rogue.physics.behavior, this, false);\n      this.behavior.add(\"collide\");\n      this.updates.push(function(dt) {\n        var behave, name, _ref;\n        _ref = this.behavior;\n        for (name in _ref) {\n          behave = _ref[name];\n          if (behave.run != null) {\n            behave.run.call(this, dt);\n          }\n        }\n        return this.intergrate(dt);\n      });\n      if ((_ref = this.vel) == null) {\n        this.vel = [0, 0];\n      }\n      if ((_ref1 = this.acc) == null) {\n        this.acc = [0, 0];\n      }\n      this.old = {};\n      if ((_ref2 = this.friction) == null) {\n        this.friction = 0;\n      }\n      if ((_ref3 = this.mass) == null) {\n        this.mass = 1;\n      }\n      return this.solid = false;\n    };\n\n    physics.prototype.intergrate = function(dt) {\n      var i, _results;\n      i = 0;\n      _results = [];\n      while (i++ < 8) {\n        _results.push(intergrate(this, dt / 8));\n      }\n      return _results;\n    };\n\n    physics.prototype.still = function() {\n      return this.vel[0] === 0 && this.vel[1] === 0 && this.acc[0] === 0 && this.acc[1] === 0;\n    };\n\n    return physics;\n\n  })();\n\n  b.gravity = (function() {\n\n    function gravity() {}\n\n    gravity.prototype.run = function() {\n      if (this.acc[1] < 9.8) {\n        this.acc[1]++;\n        if (this.acc[1] > 9.8) {\n          return this.acc[1] = 9.8;\n        }\n      }\n    };\n\n    return gravity;\n\n  })();\n\n  b.collide = (function() {\n    var responce;\n\n    function collide() {}\n\n    responce = function(col) {\n      if (col.e2.solid) {\n        if (col.dir === \"left\" || col.dir === \"right\") {\n          return this.vel[0] = 0;\n        } else {\n          return this.vel[1] = 0;\n        }\n      }\n    };\n\n    collide.prototype.onadd = function() {\n      return this.ev.on(\"hit\", responce);\n    };\n\n    collide.prototype.onremove = function() {\n      return this.ev.off(\"hit\", responce);\n    };\n\n    return collide;\n\n  })();\n\n  TileMap = (function() {\n\n    function TileMap(options) {\n      var calc, d, dirs, x, y, _i, _j, _ref, _ref1;\n      if (options == null) {\n        options = {};\n      }\n      this.x = options.x || 0;\n      this.y = options.y || 0;\n      this.res = options.res || [32, 32];\n      this.size = options.size || [100, 100];\n      this.parent = options.parent;\n      if (options.name) {\n        this.name = options.name;\n      }\n      this.components = {};\n      this.width = this.size[0] * this.res[0];\n      this.height = this.size[1] * this.res[1];\n      this.tiles = (function() {\n        var _i, _ref, _results;\n        _results = [];\n        for (y = _i = 0, _ref = this.size[0]; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {\n          _results.push((function() {\n            var _j, _ref1, _results1;\n            _results1 = [];\n            for (x = _j = 0, _ref1 = this.size[1]; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {\n              _results1.push({\n                parent: this\n              });\n            }\n            return _results1;\n          }).call(this));\n        }\n        return _results;\n      }).call(this);\n      dirs = {\n        s: [0, 1],\n        e: [1, 0],\n        n: [0, -1],\n        w: [-1, 0]\n      };\n      for (y = _i = 0, _ref = this.size[1]; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {\n        for (x = _j = 0, _ref1 = this.size[0]; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {\n          this.tiles[x][y].x = x;\n          this.tiles[x][y].y = y;\n          this.tiles[x][y].content = [];\n          for (d in dirs) {\n            calc = dirs[d];\n            this.tiles[x][y][d] = (this.tiles[x + calc[0]] != null) && (this.tiles[x + calc[0]][y + calc[1]] != null) ? this.tiles[x + calc[0]][y + calc[1]] : null;\n          }\n        }\n      }\n    }\n\n    TileMap.prototype.place = function(obj) {\n      var _this = this;\n      if (obj.forEach) {\n        return obj.forEach(function(item) {\n          return _this.place(item);\n        });\n      } else {\n        this.parent.e.push(obj);\n        obj.tile = this.tiles[obj.x][obj.y];\n        obj.parent = this.parent;\n        this.tiles[obj.x][obj.y].content.unshift(obj);\n        obj.x = obj.x * this.res[0] + this.x;\n        return obj.y = obj.y * this.res[1] + this.y;\n      }\n    };\n\n    TileMap.prototype.lookup = function(x, y) {\n      return this.tiles[x][y].content;\n    };\n\n    TileMap.prototype.clear = function() {\n      var col, tile, _i, _len, _ref, _results;\n      _ref = this.tiles;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        col = _ref[_i];\n        _results.push((function() {\n          var _j, _len1, _results1;\n          _results1 = [];\n          for (_j = 0, _len1 = col.length; _j < _len1; _j++) {\n            tile = col[_j];\n            _results1.push(tile.content = []);\n          }\n          return _results1;\n        })());\n      }\n      return _results;\n    };\n\n    TileMap.prototype.atRect = function(rect) {\n      var round, tiles, x, x1, x2, y, y1, y2, _i, _j, _ref;\n      tiles = [];\n      round = Rogue.math.round;\n      x1 = round(rect.x / this.res[0]);\n      y1 = round(rect.y / this.res[1]);\n      x2 = round((rect.x + rect.width) / this.res[0]);\n      y2 = round((rect.y + rect.height) / this.res[1]);\n      for (y = _i = y1; y1 <= y2 ? _i <= y2 : _i >= y2; y = y1 <= y2 ? ++_i : --_i) {\n        for (x = _j = x1; x1 <= x2 ? _j <= x2 : _j >= x2; x = x1 <= x2 ? ++_j : --_j) {\n          if (((_ref = this.tiles[x]) != null ? _ref[y] : void 0) != null) {\n            tiles.push(this.tiles[x][y].content);\n          }\n        }\n      }\n      return tiles;\n    };\n\n    TileMap.prototype.rect = function() {\n      return this;\n    };\n\n    return TileMap;\n\n  })();\n\n  Keyboard = (function() {\n    var chr, downFn, i, keys, num, pressedKeys, upFn, _i, _j, _len, _ref;\n\n    function Keyboard(context) {\n      var handleEvent,\n        _this = this;\n      this.context = context;\n      handleEvent = function(e) {\n        var fn, key, _ref;\n        e = e || window.event;\n        if (e.type === 'keyup') {\n          key = false;\n          fn = upFn;\n        } else {\n          key = true;\n          fn = downFn;\n        }\n        pressedKeys[e.keyCode] = key;\n        if (_ref = e.keyCode, __indexOf.call(fn, _ref) >= 0) {\n          fn[e.keyCode]();\n        }\n        return e.preventDefault();\n      };\n      this.context.onkeydown = this.context.onkeyup = handleEvent;\n    }\n\n    Keyboard.prototype.press = function(key, fn) {\n      var k, _i, _len, _results;\n      if (key.forEach) {\n        _results = [];\n        for (_i = 0, _len = key.length; _i < _len; _i++) {\n          k = key[_i];\n          _results.push(this.press(k, fn));\n        }\n        return _results;\n      } else {\n        if (keys[key] != null) {\n          return downFn[keys[key]] = fn;\n        } else {\n          return Rogue.log(3, \"invalid key: \" + key);\n        }\n      }\n    };\n\n    Keyboard.prototype.release = function(key, fn) {\n      var k, _i, _len, _results;\n      if (key.forEach) {\n        _results = [];\n        for (_i = 0, _len = key.length; _i < _len; _i++) {\n          k = key[_i];\n          _results.push(this.release(k, fn));\n        }\n        return _results;\n      } else {\n        if (keys[key] != null) {\n          return upFn[keys[key]] = fn;\n        } else {\n          return Rogue.log(3, \"invalid key: \" + key);\n        }\n      }\n    };\n\n    Keyboard.prototype.pressed = function(key) {\n      if (keys[key] != null) {\n        return pressedKeys[keys[key]];\n      } else {\n        return Rogue.log(3, \"invalid key: \" + key);\n      }\n    };\n\n    downFn = [];\n\n    upFn = [];\n\n    pressedKeys = [];\n\n    keys = {\n      backspace: 8,\n      tab: 9,\n      enter: 13,\n      shift: 16,\n      ctrl: 17,\n      alt: 18,\n      pause: 19,\n      capslock: 20,\n      escape: 27,\n      space: 32,\n      pageup: 33,\n      pagedown: 34,\n      end: 35,\n      home: 36,\n      left: 37,\n      up: 38,\n      right: 39,\n      down: 40,\n      insert: 45,\n      'delete': 46,\n      leftwin: 91,\n      rightwin: 92,\n      multiply: 106,\n      add: 107,\n      subtract: 109,\n      decimalpoint: 110,\n      divide: 111,\n      numlock: 144,\n      scrollock: 145,\n      semicolon: 186,\n      equals: 187,\n      comma: 188,\n      dash: 189,\n      period: 190,\n      forwardslash: 191,\n      backtick: 192,\n      openbracket: 219,\n      backslash: 220,\n      closebracket: 221,\n      quote: 222\n    };\n\n    for (num = _i = 0; _i < 10; num = ++_i) {\n      keys['' + num] = 48 + num;\n      keys['numpad' + num] = 96 + num;\n      keys['f' + num] = 112 + num;\n    }\n\n    _ref = 'abcdefghijklmnopqrstuvwxyz';\n    for (i = _j = 0, _len = _ref.length; _j < _len; i = ++_j) {\n      chr = _ref[i];\n      keys[chr] = 65 + i;\n    }\n\n    return Keyboard;\n\n  })();\n\n  Mouse = (function() {\n\n    function Mouse(context) {\n      var a, actions, buttons, listener, mousemove, _i, _j, _k, _len, _len1, _len2,\n        _this = this;\n      this.context = context;\n      this.context.oncontextmenu = function() {\n        return false;\n      };\n      buttons = [\"left\", \"middle\", \"right\"];\n      actions = [\"click\", \"down\", \"up\"];\n      mousemove = function(e) {\n        e = e || window.event;\n        _this.x = e.offsetX;\n        return _this.y = e.offsetX;\n      };\n      for (_i = 0, _len = buttons.length; _i < _len; _i++) {\n        b = buttons[_i];\n        this[b] = {};\n        for (_j = 0, _len1 = actions.length; _j < _len1; _j++) {\n          a = actions[_j];\n          this[b][a] = function() {};\n        }\n      }\n      for (_k = 0, _len2 = actions.length; _k < _len2; _k++) {\n        a = actions[_k];\n        listener = a === \"click\" ? \"onclick\" : \"onmouse\" + a;\n        this.context[listener] = function(e) {\n          e = e || window.event;\n          _this.context.focus();\n          _this[buttons[e.button]][e.type.replace(\"mouse\", \"\")].call(_this, e);\n          return e.preventDefault();\n        };\n      }\n      this.context.onmousemove = mousemove;\n    }\n\n    return Mouse;\n\n  })();\n\n  collision = {\n    AABB: function(r1, r2) {\n      var dir, dx, dy, h, hx, px, py, w, wy;\n      w = (r1.width + r2.width) / 2;\n      h = (r1.height + r2.height) / 2;\n      dx = (r1.x + r1.width / 2) - (r2.x + r2.width / 2);\n      dy = (r1.y + r1.height / 2) - (r2.y + r2.height / 2);\n      if (Math.abs(dx) <= w && Math.abs(dy) <= h) {\n        wy = w * dy;\n        hx = h * dx;\n        if (wy > hx) {\n          if (wy > -hx) {\n            dir = \"top\";\n          } else {\n            dir = \"left\";\n          }\n        } else {\n          if (wy > -hx) {\n            dir = \"right\";\n          } else {\n            dir = \"bottom\";\n          }\n        }\n        px = w - (dx < 0 ? -dx : dx);\n        py = h - (dy < 0 ? -dy : dy);\n        return {\n          \"dir\": dir,\n          \"pv\": [(dx < 0 ? -px : px), (dy < 0 ? -py : py)]\n        };\n      }\n      return false;\n    },\n    hitTest: function(p, r) {\n      return this.AABB({\n        x: p[0],\n        y: p[1],\n        width: 1,\n        height: 1\n      }, r);\n    },\n    AABBhitmap: function(r, e) {\n      var dir, p, points, _i, _len, _ref;\n      if (!collision.AABB(r, e.rect())) {\n        return false;\n      }\n      _ref = e.hitmap;\n      for (dir in _ref) {\n        points = _ref[dir];\n        for (_i = 0, _len = points.length; _i < _len; _i++) {\n          p = points[_i];\n          dir = this.hitTest([e.x + p[0], e.y + p[1]], r);\n          if (dir) {\n            return dir;\n          }\n        }\n      }\n      return false;\n    },\n    createHitmap: function(img, res) {\n      var hitmap, point, points, _i, _len, _step;\n      if (res == null) {\n        res = 2;\n      }\n      points = gfx.edgeDetect(img, res);\n      hitmap = {\n        left: [],\n        right: [],\n        up: [],\n        down: []\n      };\n      for (_i = 0, _len = points.length, _step = res; _i < _len; _i += _step) {\n        point = points[_i];\n        hitmap[point[2]].push([point[0], point[1]]);\n      }\n      return hitmap;\n    }\n  };\n\n  collision.SpatialHash = (function() {\n\n    function SpatialHash(cellsize) {\n      this.cellsize = cellsize;\n      this.h = {};\n    }\n\n    SpatialHash.prototype.add = function(entity) {\n      var ex, ey, hash, rect, rx, rxw, ry, ryh, x, y, _base, _ref, _results;\n      rect = entity.rect();\n      rx = Math.floor(rect.x);\n      ry = Math.floor(rect.y);\n      rxw = Math.floor(rx + rect.width);\n      ryh = Math.floor(ry + rect.height);\n      x = rx - rx % this.cellsize;\n      ex = rxw - (rxw % this.cellsize);\n      ey = ryh - (ryh % this.cellsize);\n      _results = [];\n      while (x <= ex) {\n        y = ry - ry % this.cellsize;\n        while (y <= ey) {\n          hash = \"x\" + x + \"y\" + y;\n          if ((_ref = (_base = this.h)[hash]) == null) {\n            _base[hash] = [];\n          }\n          this.h[hash].push(entity);\n          y += this.cellsize;\n        }\n        _results.push(x += this.cellsize);\n      }\n      return _results;\n    };\n\n    SpatialHash.prototype.find = function(entity) {\n      var cell, e, hash, matches, _i, _len, _ref;\n      matches = [];\n      _ref = this.h;\n      for (hash in _ref) {\n        cell = _ref[hash];\n        if (__indexOf.call(cell, entity) >= 0) {\n          for (_i = 0, _len = cell.length; _i < _len; _i++) {\n            e = cell[_i];\n            if (e !== entity) {\n              matches.push(e);\n            }\n          }\n        }\n      }\n      return matches;\n    };\n\n    SpatialHash.prototype.reset = function() {\n      this.clear();\n      return this.obj = [];\n    };\n\n    SpatialHash.prototype.clear = function() {\n      return this.h = {};\n    };\n\n    return SpatialHash;\n\n  })();\n\n  c.AABB = (function() {\n\n    function AABB() {}\n\n    AABB.prototype.type = \"AABB\";\n\n    AABB.prototype.collide = function(obj) {\n      var col,\n        _this = this;\n      if (obj.forEach) {\n        obj.forEach(function(o) {\n          return _this.collide(o);\n        });\n      }\n      if (obj.type === this.type) {\n        col = collision.AABB(this.rect(), obj.rect());\n        col.e1 = this;\n        col.e2 = obj;\n        return col;\n      } else if (obj.type === \"hitmap\") {\n        col = {};\n        col.e1 = this;\n        col.e2 = obj;\n        col.dir = collision.AABBhitmap(this.rect(), obj);\n      }\n      return false;\n    };\n\n    return AABB;\n\n  })();\n\n  c.hitmap = (function() {\n\n    function hitmap() {}\n\n    hitmap.prototype.type = \"hitmap\";\n\n    hitmap.prototype.onadd = function() {\n      return this.recalculateImage();\n    };\n\n    hitmap.prototype.recalculateImage = function() {\n      this.width = this.image.width;\n      this.height = this.image.height;\n      this.xOffset = math.round(this.width / 2);\n      this.yOffset = math.round(this.height / 2);\n      return this.hitmap = collision.createHitmap(this.image);\n    };\n\n    hitmap.prototype.collide = function(obj) {\n      var dir, dir2, opoint, point, points, points2, _i, _j, _k, _len, _len1, _len2, _ref, _ref1,\n        _this = this;\n      if (obj.forEach) {\n        obj.forEach(function(o) {\n          return _this.collide(o);\n        });\n      }\n      if (!collision.AABB(this.rect(), obj.rect())) {\n        return false;\n      }\n      if (obj.type === this.type) {\n        _ref = obj.hitmap;\n        for (dir in _ref) {\n          points = _ref[dir];\n          for (_i = 0, _len = points.length; _i < _len; _i++) {\n            opoint = points[_i];\n            _ref1 = this.hitmap;\n            for (points2 = _j = 0, _len1 = _ref1.length; _j < _len1; points2 = ++_j) {\n              dir2 = _ref1[points2];\n              for (_k = 0, _len2 = points2.length; _k < _len2; _k++) {\n                point = points2[_k];\n                if (opoint[0] + obj.x === point[0] + this.x && opoint[1] + obj.y === point[1] + this.y) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n        return false;\n      } else if (obj.type === \"AABB\") {\n        return collision.AABBhitmap(obj.rect(), this);\n      }\n    };\n\n    return hitmap;\n\n  })();\n\n  c.polygon = (function() {\n\n    function polygon() {}\n\n    polygon.prototype.type = \"polygon\";\n\n    polygon.prototype.onadd = function() {\n      if (!this.points) {\n        return log(2, \"Polygons must have points!\");\n      }\n    };\n\n    return polygon;\n\n  })();\n\n  Game = (function() {\n\n    function Game(options) {\n      var _ref, _ref1, _ref2;\n      this.options = options != null ? options : {};\n      if (this.options.canvas != null) {\n        this.canvas = document.getElementById(options.canvas);\n      }\n      if (!(this.canvas != null)) {\n        this.canvas = util.canvas();\n        document.body.appendChild(this.canvas);\n      }\n      this.canvas.tabIndex = 0;\n      this.canvas.style.outline = \"none\";\n      this.width = this.canvas.width = (_ref = this.options.width) != null ? _ref : 400;\n      this.height = this.canvas.height = (_ref1 = this.options.height) != null ? _ref1 : 300;\n      this.showFPS = (_ref2 = this.options.fps) != null ? _ref2 : false;\n      this.canvas.x = this.canvas.y = 0;\n      this.context = this.canvas.getContext('2d');\n    }\n\n    Game.prototype.start = function(state) {\n      var loading, _ref;\n      loading = (_ref = this.options.loadingScreen) != null ? _ref : function() {};\n      return this.switchState(state);\n    };\n\n    Game.prototype.switchState = function(state) {\n      this.e = [];\n      this.loop && this.loop.stop();\n      this.oldState = this.state;\n      this.state = state;\n      this.state.setup.call(this.state, this);\n      this.loop = new GameLoop(this, this.showFPS);\n      this.loop.add([this.state.update, this.state.draw]);\n      return this.loop.start();\n    };\n\n    Game.prototype.clear = function() {\n      return this.context.clearRect(0, 0, this.width, this.height);\n    };\n\n    Game.prototype.find = function(components, ex) {\n      return find.call(this, components, ex);\n    };\n\n    return Game;\n\n  })();\n\n  GameLoop = (function() {\n\n    function GameLoop(parent, showFPS) {\n      this.parent = parent;\n      this.showFPS = showFPS;\n      this.loop = __bind(this.loop, this);\n\n      this.fps = 0;\n      this.averageFPS = new RollingAverage(20);\n      this.call = [];\n    }\n\n    GameLoop.prototype.start = function() {\n      var currentTick, firstTick, lastTick;\n      this.paused = this.stopped = false;\n      firstTick = currentTick = lastTick = (new Date()).getTime();\n      return Rogue.ticker.call(window, this.loop);\n    };\n\n    GameLoop.prototype.loop = function() {\n      var func, _i, _len, _ref;\n      this.currentTick = (new Date()).getTime();\n      this.dt = (this.currentTick - this.lastTick) || 17;\n      this.fps = this.averageFPS.add(1000 / this.dt);\n      if (!(this.stopped || this.paused)) {\n        if (this.dt > 20) {\n          this.dt = 17;\n        }\n        _ref = this.call;\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          func = _ref[_i];\n          func.call(this.parent.state, this.parent, this.dt / 1000);\n        }\n      }\n      if (!this.stopped) {\n        Rogue.ticker.call(window, this.loop);\n      }\n      if (this.showFPS) {\n        this.parent.context.fillText(\"fps:\" + this.fps + \" step:\" + this.dt, 10, 10);\n      }\n      return this.lastTick = this.currentTick;\n    };\n\n    GameLoop.prototype.pause = function() {\n      return this.paused = !this.paused;\n    };\n\n    GameLoop.prototype.stop = function() {\n      return this.stopped = true;\n    };\n\n    GameLoop.prototype.add = function(func) {\n      return this.call = this.call.concat(func);\n    };\n\n    return GameLoop;\n\n  })();\n\n  RollingAverage = (function() {\n\n    function RollingAverage(size) {\n      this.size = size;\n      this.values = new Array(this.size);\n      this.count = 0;\n    }\n\n    RollingAverage.prototype.add = function(value) {\n      this.values = this.values.slice(1, this.size);\n      this.values.push(value);\n      if (this.count < this.size) {\n        this.count++;\n      }\n      return ((this.values.reduce(function(t, s) {\n        return t + s;\n      })) / this.count) | 0;\n    };\n\n    return RollingAverage;\n\n  })();\n\n  ViewPort = (function() {\n\n    function ViewPort(options) {\n      var updateHash;\n      this.options = options;\n      this.parent = this.options.parent;\n      this.canvas = this.options.canvas || this.parent.canvas || util.canvas();\n      this.context = this.canvas.getContext('2d');\n      this.width = this.options.width || this.canvas.width;\n      this.height = this.options.height || this.canvas.height;\n      this.viewWidth = this.options.viewWidth || this.width;\n      this.viewHeight = this.options.viewHeight || this.height;\n      this.viewX = this.options.viewX || 0;\n      this.viewY = this.options.viewY || 0;\n      this.x = this.options.x || 0;\n      this.y = this.options.y || 0;\n      this.e = [];\n      this.hashmap = new collision.SpatialHash(64);\n      updateHash = function() {\n        var ent, solid, _i, _len, _results;\n        solid = this.find([\"collide\"]);\n        this.hashmap.clear();\n        _results = [];\n        for (_i = 0, _len = solid.length; _i < _len; _i++) {\n          ent = solid[_i];\n          _results.push(this.hashmap.add(ent));\n        }\n        return _results;\n      };\n      this.updates = [updateHash];\n    }\n\n    ViewPort.prototype.add = function(entity) {\n      var _this = this;\n      if (entity.forEach) {\n        return entity.forEach(function(obj) {\n          return _this.add(obj);\n        });\n      } else {\n        entity.parent = this;\n        this.e.push(entity);\n        this.parent.e.push(entity);\n        if (entity.name != null) {\n          return this[entity.name] = entity;\n        }\n      }\n    };\n\n    ViewPort.prototype.remove = function(entity) {\n      var _this = this;\n      if (entity.forEach) {\n        return entity.forEach(function(obj) {\n          return _this.remove(obj);\n        });\n      } else {\n        if (entity.name != null) {\n          delete this[entity.name];\n        }\n        util.remove(this.e, entity);\n        util.remove(this.parent.e, entity);\n        return delete entity.parent;\n      }\n    };\n\n    ViewPort.prototype.update = function(dt) {\n      var entity, func, _i, _j, _len, _len1, _ref, _ref1, _results;\n      _ref = this.updates;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        func = _ref[_i];\n        if (func != null) {\n          func.call(this, dt);\n        }\n      }\n      _ref1 = this.e;\n      _results = [];\n      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n        entity = _ref1[_j];\n        if (this.close(entity) && (entity.update != null)) {\n          _results.push(entity.update(dt));\n        } else {\n          _results.push(void 0);\n        }\n      }\n      return _results;\n    };\n\n    ViewPort.prototype.draw = function() {\n      var entity, _i, _len, _ref;\n      this.context.save();\n      this.context.translate(-this.viewX, -this.viewY);\n      this.context.beginPath();\n      this.context.rect(this.x + this.viewX, this.y + this.viewY, this.width, this.height);\n      this.context.clip();\n      _ref = this.e;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        entity = _ref[_i];\n        if (this.visible(entity) && (entity.draw != null)) {\n          entity.draw();\n        }\n      }\n      return this.context.restore();\n    };\n\n    ViewPort.prototype.move = function(x, y) {\n      this.viewX += x;\n      this.viewY += y;\n      return this.keepInBounds();\n    };\n\n    ViewPort.prototype.moveTo = function(x, y) {\n      this.viewX = x;\n      this.viewY = y;\n      return this.keepInBounds();\n    };\n\n    ViewPort.prototype.follow = function(entity) {\n      this.viewX = entity.x - math.round(this.width / 2);\n      this.viewY = entity.y - math.round(this.height / 2);\n      return this.keepInBounds();\n    };\n\n    ViewPort.prototype.forceInside = function(entity, buffer) {\n      var h, w;\n      if (buffer == null) {\n        buffer = 0;\n      }\n      w = this.viewWidth;\n      h = this.viewHeight;\n      if (entity.x < buffer) {\n        entity.x = buffer;\n      }\n      if (entity.y < buffer) {\n        entity.y = buffer;\n      }\n      if (entity.x > w - buffer) {\n        entity.x = w - buffer;\n      }\n      if (entity.y > h - buffer) {\n        return entity.y = h - buffer;\n      }\n    };\n\n    ViewPort.prototype.rect = function() {\n      return {\n        width: this.width,\n        height: this.height,\n        x: this.viewX,\n        y: this.viewY\n      };\n    };\n\n    ViewPort.prototype.visible = function(entity) {\n      return collision.AABB(entity.rect(), this.rect());\n    };\n\n    ViewPort.prototype.keepInBounds = function() {\n      if (this.viewX < 0) {\n        this.viewX = 0;\n      }\n      if (this.viewY < 0) {\n        this.viewY = 0;\n      }\n      if (this.viewX + this.width > this.viewWidth) {\n        this.viewX = this.viewWidth - this.width;\n      }\n      if (this.viewY + this.height > this.viewHeight) {\n        return this.viewY = this.viewHeight - this.height;\n      }\n    };\n\n    ViewPort.prototype.find = function(components, ex) {\n      return find.call(this, components, ex);\n    };\n\n    ViewPort.prototype.close = function(entity) {\n      return collision.AABB(entity.rect(), {\n        width: this.width * 2,\n        height: this.height * 2,\n        x: this.viewX - this.width / 2,\n        y: this.viewY - this.height / 2\n      });\n    };\n\n    return ViewPort;\n\n  })();\n\n  log = function() {\n    var args, func, level;\n    level = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n    if (!(level <= Rogue.loglevel)) {\n      return;\n    }\n    switch (level) {\n      case 1:\n        func = console.error || console.log;\n        break;\n      case 2:\n        func = console.warn || console.log;\n        break;\n      case 3:\n        func = console.info || console.log;\n        break;\n      case 4:\n        func = console.debug || console.log;\n    }\n    return func.call.apply(func, [console, \"(Rogue)\"].concat(__slice.call(args)));\n  };\n\n  util = {\n    canvas: function() {\n      return document.createElement(\"canvas\");\n    },\n    imgToCanvas: function(i) {\n      var cx;\n      c = this.canvas();\n      c.src = i.src;\n      c.width = i.width;\n      c.height = i.height;\n      cx = c.getContext(\"2d\");\n      cx.drawImage(i, 0, 0, i.width, i.height);\n      return c;\n    },\n    isArray: function(value) {\n      return Object.prototype.toString.call(value) === '[object Array]';\n    },\n    remove: function(a, val) {\n      var idx;\n      idx = a.indexOf(val);\n      return idx && a.splice(idx, 1);\n    },\n    mixin: function(obj, mixin) {\n      var method, name;\n      for (name in mixin) {\n        method = mixin[name];\n        if (method !== null) {\n          if (method.slice) {\n            obj[name] = method.slice(0);\n          } else {\n            obj[name] = method;\n          }\n        }\n      }\n      return obj;\n    },\n    IE: function() {\n      return //@cc_on navigator.appVersion;\n    }\n  };\n\n  Eventer = (function() {\n\n    function Eventer(context) {\n      this.context = context;\n      this.handlers = {};\n    }\n\n    Eventer.prototype.on = function(e, func) {\n      var _base, _ref;\n      return ((_ref = (_base = this.handlers)[e]) != null ? _ref : _base[e] = []).push(func);\n    };\n\n    Eventer.prototype.off = function(e, func) {\n      return this.handlers[e] && util.remove(this.handlers[e], func);\n    };\n\n    Eventer.prototype.emit = function() {\n      var data, e, handler;\n      e = arguments[0], data = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      return this.handlers[e] && (function() {\n        var _i, _len, _ref, _results;\n        _ref = this.handlers[e];\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          handler = _ref[_i];\n          _results.push(handler.call.apply(handler, [this.context].concat(__slice.call(data))));\n        }\n        return _results;\n      }).call(this);\n    };\n\n    return Eventer;\n\n  })();\n\n  find = function(c, ex) {\n    var ent, f, found, i, _i, _j, _len, _len1, _ref;\n    found = [];\n    _ref = this.e;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      ent = _ref[_i];\n      if (!(ent !== ex)) {\n        continue;\n      }\n      f = 0;\n      for (_j = 0, _len1 = c.length; _j < _len1; _j++) {\n        i = c[_j];\n        if (ent.components[i] != null) {\n          f++;\n        }\n      }\n      if (f === c.length) {\n        found.push(ent);\n      }\n    }\n    return found;\n  };\n\n  math = {\n    round: function(num) {\n      return (0.5 + num) | 0;\n    }\n  };\n\n  math.vector = v;\n\n  Rogue = {};\n\n  Rogue.ticker = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(tick) {\n    return window.setTimeout(tick, 1000 / 60);\n  };\n\n  Rogue.ready = function(f) {\n    return document.addEventListener(\"DOMContentLoaded\", function() {\n      document.removeEventListener(\"DOMContentLoaded\", arguments.callee, false);\n      return f();\n    });\n  };\n\n  Rogue.log = log;\n\n  Rogue.util = util;\n\n  Rogue.math = math;\n\n  Rogue.physics = physics;\n\n  Rogue.Game = Game;\n\n  Rogue.GameLoop = GameLoop;\n\n  Rogue.TileMap = TileMap;\n\n  Rogue.AssetManager = AssetManager;\n\n  Rogue.SpriteSheet = SpriteSheet;\n\n  Rogue.gfx = gfx;\n\n  Rogue.collision = collision;\n\n  Rogue.Animation = Animation;\n\n  Rogue.ViewPort = ViewPort;\n\n  Rogue.components = c;\n\n  Rogue.Entity = Entity;\n\n  Rogue.Factory = Factory;\n\n  Rogue.Keyboard = Keyboard;\n\n  Rogue.Mouse = Mouse;\n\n  Rogue.loglevel = 4;\n\n  if (typeof exports === 'object') {\n    module.exports = Rogue;\n  } else if (typeof define === 'function' && define.amd) {\n    define(Rogue);\n  } else {\n    this.Rogue = Rogue;\n  }\n\n}).call(this);\n"]}